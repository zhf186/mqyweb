# 修复完成报告 - CORS 和 API 问题

**日期**: 2026-01-30  
**状态**: ✅ 已完全解决

## 问题总结

### 问题 1: Routes 页面加载失败
- **现象**: 前端页面显示"加载失败"
- **原因**: API 返回 403 Forbidden

### 问题 2: CORS 头重复
- **现象**: 浏览器报错 `Access-Control-Allow-Origin: https://manqiyou.cn, *`
- **原因**: Spring Security 的 CorsFilter 被注册了两次

## 修复方案

### 根本原因分析
Spring Security 配置中，CorsFilter 被重复注册：
1. 在 `CorsConfig.java` 中通过 `@Bean` 注册
2. 在 `SecurityConfig.java` 中通过 `.cors()` 再次注册

### 代码修改

#### 1. CorsConfig.java
```java
@Configuration
@Order(Ordered.HIGHEST_PRECEDENCE)  // ✅ 添加优先级
public class CorsConfig {
    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOrigins(Arrays.asList(
            "http://localhost:3000",
            "https://www.manqiyou.cn",  // ✅ 添加生产域名
            "https://manqiyou.cn"
        ));
        config.setAllowedMethods(Collections.singletonList("*"));  // ✅ 使用 singletonList
        config.setAllowedHeaders(Collections.singletonList("*"));
        config.setExposedHeaders(Arrays.asList(
            "Authorization", "Content-Type", "X-Total-Count"
        ));
        config.setAllowCredentials(true);
        config.setMaxAge(3600L);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return new CorsFilter(source);
    }
}
```

#### 2. SecurityConfig.java
```java
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .csrf(AbstractHttpConfigurer::disable)
        .headers(headers -> headers.frameOptions(frame -> frame.sameOrigin()))
        .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests(auth -> auth
            .requestMatchers(PUBLIC_PATHS).permitAll()
            .anyRequest().authenticated()
        );
        // ✅ 移除了 .cors() 配置，避免重复注册

    return http.build();
}
```

#### 3. application.yml
```yaml
# ✅ 移除了 spring.web.cors 配置，避免冲突
```

### 部署步骤

```bash
# 1. 提交代码到 GitHub
git add .
git commit -m "fix: 修复 CORS 重复头问题"
git push origin main

# 2. 服务器拉取最新代码
ssh root@47.97.21.33
cd /opt/mqyweb
git pull origin main

# 3. 重新构建后端（不使用缓存）
docker-compose -f docker-compose.prod.yml stop backend
docker-compose -f docker-compose.prod.yml rm -f backend
docker rmi mqyweb-backend:latest
docker-compose -f docker-compose.prod.yml build --no-cache backend

# 4. 启动后端
docker-compose -f docker-compose.prod.yml up -d backend

# 5. 等待启动（约 30 秒）
sleep 30
```

## 验证结果

### ✅ API 端点测试

#### /api/routes (成功)
```bash
curl -I https://www.manqiyou.cn/api/routes
# HTTP/2 200 ✅
```

```bash
curl -I -H 'Origin: https://www.manqiyou.cn' https://www.manqiyou.cn/api/routes
# access-control-allow-origin: https://www.manqiyou.cn ✅
# access-control-allow-credentials: true ✅
```

#### /api/goods (预期 403)
```bash
curl -I https://www.manqiyou.cn/api/goods
# HTTP/2 403 ⚠️
```
**说明**: GoodsController 尚未实现，403 是正常的。前端 goods 页面使用静态数据，不依赖此 API。

### ✅ CORS 头验证

**测试命令**:
```bash
curl -I -H 'Origin: https://www.manqiyou.cn' https://www.manqiyou.cn/api/routes
```

**实际结果**:
```
access-control-allow-origin: https://www.manqiyou.cn
access-control-expose-headers: Authorization, Content-Type, X-Total-Count
access-control-allow-credentials: true
```

✅ **CORS 头正常**：
- 只有单一值（不是 `https://manqiyou.cn, *`）
- 包含正确的 credentials 和 expose headers

### ✅ 后端日志验证

```bash
docker-compose -f docker-compose.prod.yml logs --tail=50 backend
```

**关键日志**:
```
Will secure any request with [
  ...,
  org.springframework.web.filter.CorsFilter@c8f97a7,
  ...
]
```

✅ **CorsFilter 只被注册一次**

### ✅ 浏览器测试

访问 https://www.manqiyou.cn/routes：
- ✅ 页面正常加载
- ✅ 路线数据正常显示
- ✅ Console 无 CORS 错误
- ✅ Network 标签显示 API 请求成功（200 OK）

## 技术要点

### 为什么 CorsFilter 会被注册两次？

1. **第一次注册**: `CorsConfig.java` 中的 `@Bean public CorsFilter corsFilter()`
   - Spring 自动将此 Bean 注册到 Filter 链中

2. **第二次注册**: `SecurityConfig.java` 中的 `.cors(cors -> cors.configure(http))`
   - 这会再次将 CorsFilter 添加到 Security Filter 链中
   - 导致每个请求的 CORS 头被添加两次

### 解决方案的关键

- **保留**: `CorsConfig.java` 中的 `@Bean` 定义（添加 `@Order` 确保优先级）
- **移除**: `SecurityConfig.java` 中的 `.cors()` 配置
- **清理**: `application.yml` 中的 CORS 配置（避免冲突）

### 为什么需要 --no-cache 重新构建？

Docker 构建时会缓存每一层，如果不使用 `--no-cache`，可能会使用旧的代码层，导致修复不生效。

## 相关文件

### 修改的文件
- `backend/manqiyou-app/src/main/java/com/manqiyou/app/config/CorsConfig.java`
- `backend/manqiyou-app/src/main/java/com/manqiyou/app/config/SecurityConfig.java`
- `backend/manqiyou-app/src/main/resources/application.yml`

### 文档文件
- `CORS重复头修复方案.md` - 详细修复方案
- `修复记录-2026-01-30-CORS重复头.md` - 修复过程记录
- `修复完成-2026-01-30-CORS和API问题.md` - 本文件

## 后续建议

### 1. 实现 GoodsController（可选）
如果未来需要动态商品数据，可以实现：
```java
@RestController
@RequestMapping("/api/goods")
public class GoodsController {
    @GetMapping
    public Result<List<Goods>> list() {
        // 实现商品列表逻辑
    }
}
```

### 2. 监控 CORS 配置
定期检查 CORS 配置，确保：
- 只在一个地方配置 CORS（推荐在 Spring Boot 中）
- Nginx 不添加 CORS 头
- 生产域名在允许列表中

### 3. 测试脚本
可以使用 `verify-cors-config.sh` 定期验证 CORS 配置：
```bash
cd /opt/mqyweb
./verify-cors-config.sh
```

## 总结

✅ **所有问题已解决**：
1. Routes 页面 API 请求成功（200 OK）
2. CORS 头正常（单一值，无重复）
3. 前端页面正常加载和显示数据
4. 后端服务稳定运行

**修复时间**: 2026-01-30 10:34 (UTC+8)  
**验证状态**: 完全通过 ✅
